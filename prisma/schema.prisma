generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ============================================================================
// USERS & AUTH
// ============================================================================

model User {
  id            String   @id @default(cuid())
  clerkId       String   @unique
  email         String   @unique
  firstName     String?
  lastName      String?
  imageUrl      String?

  // Plan & limits
  planId        String   @default("free_trial")
  plan          Plan     @relation(fields: [planId], references: [id])

  // Overrides (null = use plan defaults)
  maxAddedAdvertisers   Int?
  maxFollowedAdvertisers Int?
  refreshFrequency      String? // "weekly" | "monthly"
  snapshotRetentionDays Int?

  // Relationships
  userAdvertisers UserAdvertiser[]
  collections     Collection[]

  // Metadata
  role          String   @default("user") // "user" | "admin"
  isActive      Boolean  @default(false)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  lastLoginAt   DateTime?

  @@index([clerkId])
  @@index([email])
}

// ============================================================================
// PLANS
// ============================================================================

model Plan {
  id                    String   @id @default(cuid())
  name                  String   @unique // "free_trial", "starter", "pro", "agency"
  displayName           String   // "Free Trial", "Starter", "Pro", "Agency"

  // Stripe (optional for MVP)
  stripePriceId         String?  @unique
  stripePriceIdMonthly  String?
  stripePriceIdYearly   String?
  priceMonthly          Int      @default(0) // cents
  priceYearly           Int      @default(0) // cents

  // Limits
  maxAddedAdvertisers   Int      // research (add) limit
  maxFollowedAdvertisers Int     // follow (recurring) limit
  refreshFrequency      String   // "manual" | "weekly" | "monthly"
  maxCollections        Int      // -1 = unlimited
  snapshotRetentionDays Int      @default(90)
  impressionEstimates   Boolean  @default(true)

  // Metadata
  isActive              Boolean  @default(true)
  sortOrder             Int      @default(0)
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  users                 User[]
}

// ============================================================================
// ADVERTISERS
// ============================================================================

model Advertiser {
  id                String   @id @default(cuid())

  // LinkedIn data — linkedinUrl is set at creation (Add flow); linkedinCompanyId from first Apify response
  name              String
  linkedinCompanyId String?  @unique // numeric ID from Apify advertiserUrl after first scrape (e.g. "2027242")
  linkedinUrl       String?  @unique // normalized company page URL (e.g. "https://www.linkedin.com/company/simplicate/")
  logoUrl           String?  // from Apify advertiserLogo field

  // Status and scraping
  status            String   @default("approved") // "pending" | "approved" | "rejected"
  lastScrapedAt     DateTime?
  totalAdsFound     Int      @default(0)
  // Shared schedule (from highest-frequency follower)
  scrapeFrequency   String?  // "weekly" | "monthly" | null
  nextScrapeAt      DateTime?
  startUrls         Json?    // Optional: override default company search with one or more LinkedIn Ads Library URLs
  resultsLimit      Int?     // Optional: max number of ads to scrape per run (Apify results limit)

  // Relationships
  userAdvertisers   UserAdvertiser[]
  ads               Ad[]
  scrapeRuns        ScrapeRun[]

  // Metadata
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([linkedinCompanyId])
  @@index([linkedinUrl])
  @@index([name])
  @@index([scrapeFrequency, nextScrapeAt])
}

model UserAdvertiser {
  id              String   @id @default(cuid())

  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  advertiserId    String
  advertiser      Advertiser @relation(fields: [advertiserId], references: [id], onDelete: Cascade)

  // Status: added = one-time only; following = recurring; archived = was following, paused
  status          String   @default("added") // "added" | "following" | "archived"

  // Scraping
  firstTrackedAt  DateTime @default(now())
  lastScrapedAt   DateTime?
  nextScrapeAt    DateTime?
  scrapeCount     Int      @default(0)

  // Metadata
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([userId, advertiserId])
  @@index([userId, status])
  @@index([status, nextScrapeAt])
}

// ============================================================================
// ADS (Apify schema)
// ============================================================================

model Ad {
  id                    String    @id @default(cuid())

  // LinkedIn identifiers
  externalId            String    @unique // Apify "adId" — LinkedIn's ad ID
  adLibraryUrl          String?

  // Advertiser
  advertiserId          String
  advertiser            Advertiser @relation(fields: [advertiserId], references: [id], onDelete: Cascade)

  // Core content
  format                String    // "SINGLE_IMAGE" | "CAROUSEL" | "VIDEO" | etc.
  bodyText              String?   @db.Text // Apify "body" — ad copy
  headline              String?
  callToAction          String?   // First element of Apify "ctas" array
  destinationUrl        String?   // Apify "clickUrl"

  // Media — primary URL for quick access
  mediaUrl              String?   // Primary image/video URL
  mediaData             Json?     // Format-specific: slides, imageUrls, documentUrl, etc.

  // Dates and performance
  startDate             DateTime? // Apify "availability.start"
  endDate               DateTime? // Apify "availability.end"
  impressions                 String?   // Raw string like "1k-5k"
  impressionsEstimate         Int?      // Midpoint of range for sorting (e.g. 15000 from "10k-20k")
  countryImpressionsEstimate  Json?     // Per-country estimated impressions e.g. { "Belgium": 1500, "Netherlands": 13500 } for filter + sort by country

  // Targeting
  targetLanguage        String?
  targetLocation        String?

  // Thought leader (when ad is promoted by a person; from Apify thoughtLeaderMemberUrl / thoughtLeaderMemberImageUrl)
  thoughtLeaderMemberUrl        String?
  thoughtLeaderMemberImageUrl   String?

  // Metadata
  paidBy                String?
  impressionsPerCountry Json?     // Array of { country, impressions } (raw from Apify)

  // Timestamps (when we scraped)
  firstSeenAt           DateTime  @default(now())
  lastSeenAt            DateTime  @default(now())

  // Relationships
  snapshots             Snapshot[]
  collectionAds         CollectionAd[]

  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@index([externalId])
  @@index([advertiserId])
  @@index([format])
  @@index([startDate])
  @@index([endDate])
}

// ============================================================================
// SNAPSHOTS (Historical data)
// ============================================================================

model Snapshot {
  id                    String   @id @default(cuid())

  adId                  String
  ad                    Ad       @relation(fields: [adId], references: [id], onDelete: Cascade)

  // Point-in-time data
  snapshotDate          DateTime
  status                String   // "active" | "stopped"
  runtimeDays           Int
  impressionBucket      String?
  assumedImpressions    Int?
  countryData           Json?

  createdAt             DateTime @default(now())

  @@index([adId, snapshotDate])
  @@index([snapshotDate])
}

// ============================================================================
// COLLECTIONS
// ============================================================================

model Collection {
  id              String   @id @default(cuid())

  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  name            String
  description     String?  @db.Text

  collectionAds   CollectionAd[]

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([userId])
}

model CollectionAd {
  id              String   @id @default(cuid())

  collectionId    String
  collection      Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)

  adId            String
  ad              Ad       @relation(fields: [adId], references: [id], onDelete: Cascade)

  addedAt         DateTime @default(now())

  @@unique([collectionId, adId])
  @@index([collectionId])
  @@index([adId])
}

// ============================================================================
// SCRAPE RUNS (Apify audit log)
// ============================================================================

model ScrapeRun {
  id              String    @id @default(cuid())

  advertiserId    String
  advertiser      Advertiser @relation(fields: [advertiserId], references: [id], onDelete: Cascade)

  apifyRunId      String?
  apifyDatasetId  String?

  /** "initial" = one-time add; "scheduled" = recurring follow-up. Affects storeAds behaviour and Advertiser lastScrapedAt/nextScrapeAt. */
  jobType         String?   // "initial" | "scheduled"

  status          String    @default("pending") // "pending" | "running" | "completed" | "failed"
  adsFound        Int       @default(0)
  adsNew          Int       @default(0)
  adsUpdated      Int       @default(0)
  costUsd         Float?
  errorMessage    String?   @db.Text

  startedAt       DateTime  @default(now())
  completedAt     DateTime?

  @@index([advertiserId])
  @@index([status])
}
